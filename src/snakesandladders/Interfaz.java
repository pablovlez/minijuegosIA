/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * Interfaz.java
 *
 * Created on 3/09/2010, 06:47:39 PM
 */
package snakesandladders;

import java.awt.Cursor;
import java.util.ArrayList;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;

/**
 *
 * @author Pablo Velez
 */
public class Interfaz extends javax.swing.JFrame {

    /** Creates new form Interfaz */
    int mundo[][] = null;
    private ArrayList ruta;
    HiloMax l;
    int a;
    public double dadoMax = 0;
    public double dadoMin = 0;
    double avanceMaxX = 80;
    double avanceMaxY = 490;
    double avanceMinX = 75;
    double avanceMinY = 490;
    String ganadorMini;
    boolean avanzaMin = true;
    boolean avanzaMax = true;
    int[] posMax = {7, -1};
    int[] posMin = {7, -1};
    boolean turnoMaquina = true;
    int numeroAleatorio = (int) (Math.random() * 2 + 1);
    public HiloMax hiloMax = new HiloMax();
    public HiloMin hiloMin = new HiloMin();

    public Interfaz() {
        super("SankesAndLadders");
        initComponents();
        if (numeroAleatorio == 1) {
            turnoMaquina = false;
            JOptionPane.showMessageDialog(this, "Empiezas el Juego");
        } else {
            JOptionPane.showMessageDialog(this, "La Maquina empieza el Juego");
            turnoMaquina = true;
        }

        if (turnoMaquina == true) {
            dadoMax = (int) (Math.random() * 6 + 1);
            System.out.println("MAX saco " + dadoMax);
            hiloMax.iniciar();
        }




    }

    public void empezar() {
        lbPlayer2.setBounds(40, 470, 70, 90);
        lbPlayer1.setBounds(50, 510, 70, 90);
        dadoMax = 0;
        dadoMin = 0;
        avanceMaxX = 80;
        avanceMaxY = 490;
        avanceMinX = 75;
        avanceMinY = 490;
        ganadorMini = "";
        avanzaMin = true;
        avanzaMax = true;
        posMax[0] = 7;
        posMax[1] = -1;
        posMin[0] = 7;
        posMin[1] = -1;
        turnoMaquina = true;
        numeroAleatorio = (int) (Math.random() * 2 + 1);
        if (numeroAleatorio == 1) {
            turnoMaquina = false;
            JOptionPane.showMessageDialog(this, "Empiezas el Juego");
        } else {
            JOptionPane.showMessageDialog(this, "La Maquina empieza el Juego");
            turnoMaquina = true;
        }

        if (turnoMaquina == true) {
            dadoMax = (int) (Math.random() * 6 + 1);
            System.out.println("MAX saco " + dadoMax);
            hiloMax.iniciar();
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setLayout(null);

        lbPlayer1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/tablero/player1.png"))); // NOI18N
        jPanel1.add(lbPlayer1);
        lbPlayer1.setBounds(50, 510, 70, 90);

        lbPlayer2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/tablero/player2.png"))); // NOI18N
        jPanel1.add(lbPlayer2);
        lbPlayer2.setBounds(40, 470, 70, 90);

        lbDado.setFont(new java.awt.Font("Arial", 1, 36));
        lbDado.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lbDado.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/dados/dados.gif"))); // NOI18N
        jPanel1.add(lbDado);
        lbDado.setBounds(770, 120, 70, 70);

        btnLanzar.setText("Lanzar");
        btnLanzar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLanzarActionPerformed(evt);
            }
        });
        jPanel1.add(btnLanzar);
        btnLanzar.setBounds(750, 310, 110, 23);

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/tablero/tablero.jpg"))); // NOI18N
        jPanel1.add(jLabel1);
        jLabel1.setBounds(130, 80, 590, 510);

        jLabel2.setFont(new java.awt.Font("Tempus Sans ITC", 1, 16));
        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel2.setText("S N A K E S  -N-  L A D D E R S + +");
        jPanel1.add(jLabel2);
        jLabel2.setBounds(130, 20, 600, 30);

        getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);

        jMenu1.setText("Juego");

        jMenuItem1.setText("Reiniciar");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Acerca de");
        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-909)/2, (screenSize.height-689)/2, 909, 689);
    }// </editor-fold>//GEN-END:initComponents

    private void btnLanzarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLanzarActionPerformed
        // TODO add your handling code here:
        lbDado.setIcon(dados[0]);
        setDadoMin((int) (Math.random() * 6 + 1));

        System.out.println("MIN saco " + getDadoMin());
        if (hiloMin.animationThread != null) {
            hiloMin.detener();
        } else {
            hiloMin.iniciar();

        }


    }//GEN-LAST:event_btnLanzarActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        // TODO add your handling code here:
        empezar();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new Interfaz().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    public static final javax.swing.JButton btnLanzar = new javax.swing.JButton();
    public static final javax.swing.JLabel jLabel1 = new javax.swing.JLabel();
    public static final javax.swing.JLabel jLabel2 = new javax.swing.JLabel();
    public static final javax.swing.JMenu jMenu1 = new javax.swing.JMenu();
    public static final javax.swing.JMenu jMenu2 = new javax.swing.JMenu();
    public static final javax.swing.JMenuBar jMenuBar1 = new javax.swing.JMenuBar();
    public static final javax.swing.JMenuItem jMenuItem1 = new javax.swing.JMenuItem();
    public static final javax.swing.JPanel jPanel1 = new javax.swing.JPanel();
    public static final javax.swing.JLabel lbDado = new javax.swing.JLabel();
    public static final javax.swing.JLabel lbPlayer1 = new javax.swing.JLabel();
    public static final javax.swing.JLabel lbPlayer2 = new javax.swing.JLabel();
    // End of variables declaration//GEN-END:variables

    public void terminaJuegoMAX() {
        if (posMax[0] == 0 && posMax[1] == 0 && dadoMax == 0) {
            JOptionPane.showMessageDialog(this, "El Juego ha terminado, gana la Maquina");
            System.exit(0);
        }
    }

    public void terminaJuegoMIN() {
        if (posMin[0] == 0 && posMin[1] == 0 && dadoMin == 0) {
            JOptionPane.showMessageDialog(this, "El Juego ha terminado, has ganado");
            System.exit(0);
        }
    }

    public void jugar() {


        //System.out.println("Pausamos el hilo de min");
        while (turnoMaquina == true) {

            setDadoMax((int) (Math.random() * 6 + 1));

            System.out.println("Dado de Max " + getDadoMax());
            turnoMaquina = false;

            if (hiloMax.animationThread != null) {

                hiloMax.detener();
            } else {
                hiloMax.iniciar();
            }
        }
        hiloMin.detener();

    }

    /**
     * @return the dadoMax
     */
    public double getDadoMax() {
        return dadoMax;
    }

    /**
     * @param dadoMax the dadoMax to set
     */
    public void setDadoMax(double dadoMax) {
        this.dadoMax = dadoMax;
    }

    /**
     * @return the dadoMin
     */
    public double getDadoMin() {
        return dadoMin;
    }

    /**
     * @param dadoMin the dadoMin to set
     */
    public void setDadoMin(double dadoMin) {
        this.dadoMin = dadoMin;
    }

//////************************/Hilos para llamar los metodos de moverse para max ///////
    public class HiloMax implements Runnable {

        //private boolean continuar = true;
        public HiloMax() {
        }
        // metodo para poner el boolean a false.
        private Thread animationThread = null;

        public void run() {
            Thread currentThread = Thread.currentThread();
            lbDado.setIcon(dados[(int) getDadoMax()]);
            while (currentThread == animationThread && 0 < getDadoMax()) {
                setCursor(Cursor.WAIT_CURSOR);
                btnLanzar.setEnabled(false);
                if (avanzaMax) {
                    moverseMax();
                } else {
                    retrocederMax(1);
                }
                System.out.println("Dado de Max " + getDadoMax());
                setDadoMax(getDadoMax() - 1);
                try {
                    animationThread.sleep(500);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
            snakesNLaddersMAX(posMax, avanceMaxX, avanceMaxY);
            terminaJuegoMAX();
            mismaCasillaMax();
            if (avanzaMax == false && getDadoMax() == 0) {
                avanzaMax = true;
            }
            btnLanzar.setEnabled(true);
            setCursor(Cursor.getDefaultCursor());
            detener();

        }

        public void iniciar() {
            if (this.animationThread == null) {
                this.animationThread = new Thread(this, "hilomax");
                this.animationThread.start();
            }

        }

        public void detener() {
            this.animationThread = null;
        }
    }
//////************************/Hilos para llamar los metodos de moverse para min ///////

    public class HiloMin implements Runnable {

        //private boolean continuar = true;
        public HiloMin() {
        }
        // metodo para poner el boolean a false.
        private Thread animationThread = null;

        public void run() {
            Thread currentThread = Thread.currentThread();
            lbDado.setIcon(dados[(int) getDadoMin()]);
            while (currentThread == animationThread && 0 < getDadoMin()) {
                setCursor(Cursor.WAIT_CURSOR);
                btnLanzar.setEnabled(false);
                if (avanzaMin) {
                    moverseMin();
                } else {
                    retrocederMin(1);
                }

                System.out.println("Dado de Min " + getDadoMin());
                setDadoMin(getDadoMin() - 1);
                try {
                    animationThread.sleep(500);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }

            }
            turnoMaquina = true;
            System.out.println("Cambiamos el turno de la maquina a true");
            snakesNLaddersMIN(posMin, avanceMinX, avanceMinY);
            terminaJuegoMIN();
            mismaCasillaMin();

            if (avanzaMin == false && getDadoMin() == 0) {
                avanzaMin = true;
            }
            jugar();

        }

        public void iniciar() {
            if (this.animationThread == null) {
                this.animationThread = new Thread(this, "hilomin");
                this.animationThread.start();
            }

        }

        public void detener() {
            this.animationThread = null;
        }
    }
    /***************************************************/
    /*****************Arreglo de iconos de los numeros del dado*****************/
    public ImageIcon[] dados = {new javax.swing.ImageIcon(getClass().getResource("/images/dados/dados.gif")),
        new javax.swing.ImageIcon(getClass().getResource("/images/dados/1.jpg")),
        new javax.swing.ImageIcon(getClass().getResource("/images/dados/2.jpg")),
        new javax.swing.ImageIcon(getClass().getResource("/images/dados/3.jpg")),
        new javax.swing.ImageIcon(getClass().getResource("/images/dados/4.jpg")),
        new javax.swing.ImageIcon(getClass().getResource("/images/dados/5.jpg")),
        new javax.swing.ImageIcon(getClass().getResource("/images/dados/6.jpg"))
    };

    /*****************Metodo para mover a max*****************/
    public void moverseMax() {

        if (posMax[0] % 2 != 0) {
            posMax[1] += 1;

            avanceMaxX += 70;
            System.out.println("Coor MAXX " + avanceMaxX);
            System.out.println("Coor MAXY " + avanceMaxY);
            if (posMax[1] > 7) {
                posMax[0] -= 1;
                posMax[1] = 7;
                avanceMaxY -= 65;
                avanceMaxX = 640;
            }
        } else {
            posMax[1] -= 1;

            avanceMaxX -= 70;
            //System.out.println("Coor MAXX " + avanceMaxX);
            // System.out.println("Coor MAXY " + avanceMaxY);
            if (posMax[1] < 0) {
                posMax[0] -= 1;
                posMax[1] = 0;
                avanceMaxY -= 65;
                avanceMaxX = 150;
            }
        }
        lbPlayer1.setBounds((int) avanceMaxX, (int) avanceMaxY, 70, 90);
        if (posMax[0] == 0 && posMax[1] == 0 && dadoMax > 0) {
            avanzaMax = false;
        }

    }

    /*****************Metodo para mover a min*****************/
    public void moverseMin() {


        if (posMin[0] % 2 != 0) {
            posMin[1] += 1;
            avanceMinX += 70;

            if (posMin[1] > 7) {
                posMin[0] -= 1;
                posMin[1] = 7;
                avanceMinY -= 65;
                avanceMinX = 635;
            }
        } else {
            posMin[1] -= 1;
            avanceMinX -= 70;
            if (posMin[1] < 0) {
                posMin[0] -= 1;
                posMin[1] = 0;
                avanceMinY -= 65;
                avanceMinX = 145;
            }
        }
        lbPlayer2.setBounds((int) avanceMinX, (int) avanceMinY, 70, 90);
        if (posMin[0] == 0 && posMin[1] == 0 && dadoMin > 0) {
            avanzaMin = false;
        }

    }

    /*****************Metodo para retroceder a min, le entra como parametro la cantidad de casillas q se devolvera*****************/
    public void retrocederMin(int a) {

        for (int i = 1; i <= a; i++) {

            if (posMin[0] % 2 != 0) {
                posMin[1] -= 1;

                avanceMinX -= 70;

                if (posMin[1] < 0) {
                    posMin[0] += 1;
                    posMin[1] = 0;
                    avanceMinY += 65;
                    avanceMinX = 145;
                }
            } else {
                posMin[1] += 1;
                avanceMinX += 70;

                if (posMin[1] > 7) {
                    posMin[0] += 1;
                    posMin[1] = 7;
                    avanceMinY += 65;
                    avanceMinX = 635;
                }
            }
        }

        lbPlayer2.setBounds((int) avanceMinX, (int) avanceMinY, 70, 90);
        if (posMin[0] >= 7 && avanceMinY > 490) {
            lbPlayer2.setBounds(145, 490, 70, 90);
            posMin[0] = 7;
            posMin[1] = -1;
            avanceMinX = 75;
            avanceMinY = 490;
        }


    }

    /*****************Metodo para retroceder a max, le entra como parametro la cantidad de casillas q se devolvera*****************/
    public void retrocederMax(int a) {

        for (int i = 1; i <= a; i++) {

            if (posMax[0] % 2 != 0) {
                posMax[1] -= 1;
                avanceMaxX -= 70;

                if (posMax[1] < 0) {
                    posMax[0] += 1;
                    posMax[1] = 0;
                    avanceMaxY += 65;
                    avanceMaxX = 145;
                }
            } else {
                posMax[1] += 1;
                avanceMaxX += 70;

                if (posMax[1] > 7) {
                    posMax[0] += 1;
                    posMax[1] = 7;
                    avanceMaxY += 65;
                    avanceMaxX = 635;
                }
            }
        }
        lbPlayer1.setBounds((int) avanceMaxX, (int) avanceMaxY, 70, 90);
        if (posMax[0] >= 7 && avanceMaxY > 490) {
            lbPlayer2.setBounds(150, 490, 70, 90);
            posMax[0] = 7;
            posMax[1] = -1;
            avanceMaxX = 80;
            avanceMaxY = 490;
        }


    }

    /*****************Metodo para verificar si max se encuentra en una escalera o en una serpiente*****************/
    public void snakesNLaddersMAX(int[] pos, double x, double y) {
        ///////////////Ladders////////////////
        int[] arr = new int[4];
        arr[0] = pos[0];
        arr[1] = pos[1];
        arr[2] = (int) x;
        arr[3] = (int) y;
        if (pos[0] == 6 && pos[1] == 4) {
            arr[0] = 4;
            arr[1] = 4;
            arr[2] = (int) (x);
            arr[3] = (int) (y - (65 * 2));

        }
        if (pos[0] == 5 && pos[1] == 0) {
            arr[0] = 3;
            arr[1] = 0;
            arr[2] = (int) (x);
            arr[3] = (int) (y - (65 * 2));
        }
        if (pos[0] == 2 && pos[1] == 7) {
            arr[0] = 0;
            arr[1] = 7;
            arr[2] = (int) (x);
            arr[3] = (int) (y - (65 * 2));
        }
        ////////////Snakes/////////////////
        if (pos[0] == 4 && pos[1] == 5) {
            arr[0] = 6;
            arr[1] = 6;
            arr[2] = (int) (x + 70);
            arr[3] = (int) (y + (65 * 2));
        }
        if (pos[0] == 4 && pos[1] == 1) {
            arr[0] = 7;
            arr[1] = 3;
            arr[2] = (int) (x + (70 * 2));
            arr[3] = (int) (y + (65 * 3));
        }
        if (pos[0] == 3 && pos[1] == 2) {
            arr[0] = 4;
            arr[1] = 3;
            arr[2] = (int) (x + 70);
            arr[3] = (int) (y + 65);
        }
        if (pos[0] == 1 && pos[1] == 6) {
            arr[0] = 2;
            arr[1] = 4;
            arr[2] = (int) (x - (70 * 2));
            arr[3] = (int) (y + 65);
        }
        if (pos[0] == 0 && pos[1] == 3) {
            arr[0] = 1;
            arr[1] = 4;
            arr[2] = (int) (x + 70);
            arr[3] = (int) (y + 65);
        }
        if (pos[0] == 0 && pos[1] == 1) {
            arr[0] = 2;
            arr[1] = 0;
            arr[2] = (int) (x - 70);
            arr[3] = (int) (y + (65 * 2));
        }

        posMax[0] = arr[0];
        posMax[1] = arr[1];
        avanceMaxX = arr[2];
        avanceMaxY = arr[3];
        lbPlayer1.setBounds((int) avanceMaxX, (int) avanceMaxY, 70, 90);
        if (posMax[0] == 7 && posMax[1] == 0) {
            lbPlayer1.setBounds(150, 490, 70, 90);
        }

    }

    /*****************Metodo para verificar si min se encuentra en una escalera o en una serpiente*****************/
    public void snakesNLaddersMIN(int[] pos, double x, double y) {
        ///////////////Ladders////////////////
        int[] arr = new int[4];
        arr[0] = pos[0];
        arr[1] = pos[1];
        arr[2] = (int) x;
        arr[3] = (int) y;
        if (pos[0] == 6 && pos[1] == 4) {
            arr[0] = 4;
            arr[1] = 4;
            arr[2] = (int) (x);
            arr[3] = (int) (y - (65 * 2));

        }
        if (pos[0] == 5 && pos[1] == 0) {
            arr[0] = 3;
            arr[1] = 0;
            arr[2] = (int) (x);
            arr[3] = (int) (y - (65 * 2));
        }
        if (pos[0] == 2 && pos[1] == 7) {
            arr[0] = 0;
            arr[1] = 7;
            arr[2] = (int) (x);
            arr[3] = (int) (y - (65 * 2));
        }
        ////////////Snakes/////////////////
        if (pos[0] == 4 && pos[1] == 5) {
            arr[0] = 6;
            arr[1] = 6;
            arr[2] = (int) (x + 70);
            arr[3] = (int) (y + (65 * 2));
        }
        if (pos[0] == 4 && pos[1] == 1) {
            arr[0] = 7;
            arr[1] = 3;
            arr[2] = (int) (x + (70 * 2));
            arr[3] = (int) (y + (65 * 3));
        }
        if (pos[0] == 3 && pos[1] == 2) {
            arr[0] = 4;
            arr[1] = 3;
            arr[2] = (int) (x + 70);
            arr[3] = (int) (y + 65);
        }
        if (pos[0] == 1 && pos[1] == 6) {
            arr[0] = 2;
            arr[1] = 4;
            arr[2] = (int) (x - (70 * 2));
            arr[3] = (int) (y + 65);
        }
        if (pos[0] == 0 && pos[1] == 3) {
            arr[0] = 1;
            arr[1] = 4;
            arr[2] = (int) (x + 70);
            arr[3] = (int) (y + 65);
        }
        if (pos[0] == 0 && pos[1] == 1) {
            arr[0] = 2;
            arr[1] = 0;
            arr[2] = (int) (x - 70);
            arr[3] = (int) (y + (65 * 2));
        }

        posMin[0] = arr[0];
        posMin[1] = arr[1];
        avanceMinX = arr[2];
        avanceMinY = arr[3];
        lbPlayer2.setBounds((int) avanceMinX, (int) avanceMinY, 70, 90);


    }

    /*****************Metodo para verificar si min llega a una casilla en la que se encuentra max, *****************/
    /***************luego se abre aleatoriamente un minijuego en el cual empieza max********************************************/
    public void mismaCasillaMin() {
        if (posMin[0] == posMax[0] && posMin[1] == posMax[1]) {
            JOptionPane.showMessageDialog(this, "Ambos se encuentran en la misma casilla\n Deberas derrotarlo en el minijuego para permanecer la casilla ");
            numeroAleatorio = (int) (Math.random() * 3 + 1);
            if (numeroAleatorio == 1) {
                PizzaGui p = new PizzaGui(true);
                p.setVisible(true);
                while (p.ganador == null) {
                }
                ganadorMini = p.ganador;
                p = null;
                if (ganadorMini.equals("MAX")) {
                    retrocederMin(6);
                } else {
                    retrocederMax(6);
                }

            } else {
                if (numeroAleatorio == 2) {
                    PrecipicioGui preci = new PrecipicioGui(true);
                    preci.setVisible(true);
                    while (preci.ganador == null) {
                    }
                    ganadorMini = preci.ganador;
                    if (ganadorMini.equals("MAX")) {
                        retrocederMin(4);
                    }
                    if (ganadorMini.equals("MIN")) {
                        retrocederMax(4);
                    }
                    if (ganadorMini.equals("EMP") || ganadorMini.equals("EMPC")) {
                        retrocederMin(3);
                        retrocederMax(3);
                    }
                    if (ganadorMini.equals("MAXC")) {
                        retrocederMin(6);
                    }
                    if (ganadorMini.equals("MINC")) {
                        retrocederMax(6);
                    }

                } else {
                    if (numeroAleatorio == 3) {
                        TerritorioGui terri = new TerritorioGui(true);
                        terri.setVisible(true);
                        while (terri.ganador == null) {
                        }
                        ganadorMini = terri.ganador;
                        if (ganadorMini.equals("MAX")) {
                            retrocederMin(4);
                        }
                        if (ganadorMini.equals("MIN")) {
                            retrocederMax(4);
                        }
                        if (ganadorMini.equals("EMP")) {
                            retrocederMin(3);
                            retrocederMax(3);
                        }
                    }
                }
            //////poner aca la condicion de si el numeroaleatorio es 3 abrir el minijuego de territorio
            /////y poner las condiciones para retroceder y llamar al metodo retroceder con el numero de casillas q debe retroceder
            }
        }
    }

    /**************Metodo para verificar si max llega a una casilla en la que se encuentra min, *****************/
    /***************luego se abre aleatoriamente un minijuego en el cual empieza min********************************************/
    public void mismaCasillaMax() {
        if (posMin[0] == posMax[0] && posMin[1] == posMax[1]) {
            JOptionPane.showMessageDialog(this, "Ambos se encuentran en la misma casilla\n Deberas derrotarlo en el minijuego para permanecer en tu casilla ");
            numeroAleatorio = (int) (Math.random() * 3 + 1);//////////cambiar el numero aleatorio a 3
            if (numeroAleatorio == 1) {

                PizzaGui p = new PizzaGui(false);
                p.setVisible(true);
                while (p.ganador == null) {
                }
                ganadorMini = p.ganador;
                p = null;
                if (ganadorMini.equals("MAX")) {
                    retrocederMin(6);
                } else {
                    retrocederMax(6);
                }

            } else {
                if (numeroAleatorio == 2) {
                    PrecipicioGui preci = new PrecipicioGui(false);
                    preci.setVisible(true);
                    while (preci.ganador == null) {
                    }
                    ganadorMini = preci.ganador;
                    if (ganadorMini.equals("MAX")) {
                        retrocederMin(4);
                    }
                    if (ganadorMini.equals("MIN")) {
                        retrocederMax(4);
                    }
                    if (ganadorMini.equals("EMP") || ganadorMini.equals("EMPC")) {
                        retrocederMin(3);
                        retrocederMax(3);
                    }
                    if (ganadorMini.equals("MAXC")) {
                        retrocederMin(6);
                    }
                    if (ganadorMini.equals("MINC")) {
                        retrocederMax(6);
                    }

                }else {
                    if (numeroAleatorio == 3) {
                        TerritorioGui terri = new TerritorioGui(true);
                        terri.setVisible(true);
                        while (terri.ganador == null) {
                        }
                        ganadorMini = terri.ganador;
                        if (ganadorMini.equals("MAX")) {
                            retrocederMin(4);
                        }
                        if (ganadorMini.equals("MIN")) {
                            retrocederMax(4);
                        }
                        if (ganadorMini.equals("EMP")) {
                            retrocederMin(3);
                            retrocederMax(3);
                        }
                    }
                }
            }
        }
    }
}

